---
title: Database
date: 2021-03-23 21:11:22 +0800
categories: [java, database]
tags: [database]
---
[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
# ACID
事务（Transaction）：访问并可能更新数据库中各种数据项的一个程序执行单元（unit）
- 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚
- 一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.
> A要向B支付100元,而A的账户中只有90元,并且我们给定账户余额这一列的约束是,不能小于0.那么很明显这条事务执行会失败,因为90-100=-10,小于我们给定的约束了.这个例子里,支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证.
- 隔离性（Isolation）: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
- 持久性（Durability）: 指一旦事务提交成功，其对数据的修改是持久性的。数据更新的结果已经从内存转存到外部存储器上，此后即使发生了系统故障，已提交事务所做的数据更新也不会丢失。
# InnoDB引擎的事务实现
而事务的ACID是通过**InnoDB日志**和**锁**来保证。事务的隔离性是通过数据库锁的机制实现的，
持久性通过redo log(重做日志)来实现，原子性和一致性通过Undo log(回撤日志)来实现。
Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方
（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了
roll back语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 和Undo Log相反，
Redo Log记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。
当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

# 两段锁
将事务分成两个阶段，加锁阶段和解锁阶段。
- 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
- 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

# 事务并发可能出现的问题
- 脏读（Dirty Read）： 一个事务读到了另一个未提交事务修改过的数据
- 不可重复读（Non-Repeatable Read）
- 幻读（Phantom）：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。

# 事务的四种隔离级别
在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。
![](../assets/img/sample/Innodb.png)

# MVCC
